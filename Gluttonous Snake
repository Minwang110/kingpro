#define SNAKE_SYMBOL	'@'		/* snake body and food symbol */
#define FOOD_SYMBOL		'*'
#define MAX_NODE		30		/* maximum snake nodes */
#define DFL_SPEED		50		/* snake default speed */
#define TOP_ROW		5			/* top_row */
#define BOT_ROW		LINES - 1
#define LEFT_EDGE	0
#define RIGHT_EDGE	COLS - 1
typedef struct node			/* Snake_node structure */
{
	int x_pos;
	int y_pos;
	struct node *prev;
	struct node *next;
} Snake_Node;
struct position				 
{
	int x_pos;
	int y_pos;
} ;
void Init_Disp();			 
void Food_Disp();			 
void Wrap_Up();				
void Key_Ctrl();			 
int set_ticker(int n_msecs);
void DLL_Snake_Create();	
void DLL_Snake_Insert(int x, int y);	
void DLL_Snake_Delete_Node();	
void DLL_Snake_Delete();		 
void Snake_Move();			 
void gameover(int n);	
void Init_Disp()
{
	char wall = ' ';
	int i, j;
	initscr();
	cbreak();			 
	noecho();
	curs_set(0);			 
	attrset(A_NORMAL);		 
	attron(A_REVERSE);		 
	for(i = 0; i < LINES; i++)
	{
		mvaddch(i, LEFT_EDGE, wall);
		mvaddch(i, RIGHT_EDGE, wall);
	}
	for(j = 0; j < COLS; j++)
	{
		mvaddch(0, j, '=');
		mvaddch(TOP_ROW, j, wall);
		mvaddch(BOT_ROW, j, wall);
	}
	attroff(A_REVERSE);		
	mvaddstr(1, 2, "Game: snake    version: 1.0    date: 2011/08/22");
	mvaddstr(2, 2, "Author: Dream Fly	Blog: blog.csdn.net/jjzhoujun2010");
	mvaddstr(3, 2, "Usage: Press 'f' to speed up, 's' to speed down,'q' to quit.");
    mvaddstr(4, 2, "       Nagivation key controls snake moving.");
	refresh();
}
void Food_Disp()
{
	srand(time(0));
	food.x_pos = rand() % (COLS - 2) + 1;
	food.y_pos = rand() % (LINES - TOP_ROW - 2) + TOP_ROW + 1;
	mvaddch(food.y_pos, food.x_pos, FOOD_SYMBOL); 
	refresh();
}
void DLL_Snake_Create()
{
	Snake_Node *temp = (Snake_Node *)malloc(sizeof(Snake_Node));
	head = (Snake_Node *)malloc(sizeof(Snake_Node));
	tail = (Snake_Node *)malloc(sizeof(Snake_Node));
	if(temp == NULL || head == NULL || tail == NULL)
	perror("malloc");
	temp->x_pos = 5;
	temp->y_pos = 10;
	head->prev =NULL;
	tail->next = NULL;
	head->next = temp;
	temp->next = tail;
	tail->prev = temp;
	temp->prev = head;
	mvaddch(temp->y_pos, temp->x_pos, SNAKE_SYMBOL);
	refresh();
}
int set_ticker(int n_msecs)
{
	struct itimerval new_timeset;
	long n_sec, n_usecs;
    n_sec = n_msecs / 1000;					 
	n_usecs = (n_msecs % 1000) * 1000L;		 
	new_timeset.it_interval.tv_sec = n_sec;	 
	new_timeset.it_interval.tv_usec = n_usecs;
new_timeset.it_value.tv_sec = n_sec;	 
	new_timeset.it_value.tv_usec = n_usecs;
    return setitimer(ITIMER_REAL, &new_timeset, NULL);
}
